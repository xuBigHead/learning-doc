# 对象实例化

## 创建对象

1. **加载类元信息**

    虚拟机遇到一条new指令，首先去检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化。(即判断类元信息是否存在)。如果没有，那么在双亲委派模式下，使用当前类加载器以ClassLoader+包名+类名为Key进行查找对应的.class文件。如果没有找到文件，则抛出ClassNotFoundException异常，如果找到，则进行类加载，并生成对应的Class类对象

2. **为对象分配内存**

    首先计算对象占用空间大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即4个字节大小。

    *指针碰撞*：如果内存是规整的，那么虚拟机将采用的是指针碰撞法( Bump The Pointer )来为对象分配内存。意思是所有用过的内存在一边，空闲的内存在另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是Serial、ParNew这种基于压缩算法的,虚拟机采用这种分配方式。一股使用带有compact (整理)过程的收集器时，使用指针碰撞。

    如果内存不是规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表,记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式成为"空闲列表(Free List)。

    选择哪种分配方式由Java堆是否规整决定,而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

3. **处理并发安全问题**

4. **属性的默认初始化**

5. **设置对象头的信息**

    将对象的所属类(即类的元数据信息)、对象的HashCode和对象的GC信息、 锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现。

6. **属性的显式初始化、代码块初始化、构造器初始化**

    在Java程序的视角看来，初始化才正式开始。*初始化成员变量，执行实例化代码块，调用类的构造方法*，并把堆内对象的首地址赋值给引用变量。因此一般来说(由字节码中是否跟随有invokespecial指令所决定)， new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。



## 对象内存布局

1. 对象头（Header）
    - 运行时元数据
        - hashcode
        - GC分代年龄
        - 锁状态标志
        - 线程持有的锁
        - ...
    - 类型指针
        - 指向类元数据，确定该对象的类型
2. 实例数据（Instance Data）
    - 字段信息
3. 对齐填充（Padding）

实例

```java
public class CustomerTest {
	public static main(String[] args) {
        Customer cust = new Customer();
    }
}
```



## 对象访问定位

JVM是如何通过栈帧中的对象引用访问到其内部的对象实例的呢？

**对象访问的两种方式**

1. 句柄访问

    好处：reference中存储稳定句柄地址，对象被移动(垃圾收集时移动对象很普遍)时只会改变句柄中实例数据指针即可，reference本身不需要被修改。

    

2. 直接指针（hotspot JVM采用）



## StringTable

### String的基本特性

- String: 字符串，使用一对""引起来表示
- String声明为final的，**不可被继承**
- String实现了Serializable接口：表示字符串是支持序列化的。
- 实现了Comparable接口：表示String可以比较大小。
- String在jdk8及以前内部定义了final char[] value用于存储字符串数据。jdk9时改为byte[]
- String：**代表不可变的字符序列**。简称:不可变性。
    - 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
    - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
    - 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
- 通过字面量的方式(区别于new)给一个字符串赋值，此时的字符串值声明在字符串常量池中。
- **字符串常量池中是不会存储相同内容的字符串的**
    - String的String Pool是一个固定大小的Hashtable，默认值大小长度是1009。如果放进string Pool的String非常多， 就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。
    - 使用-XX: StringTableSi ze可设置StringTable的长度
    - 在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求
    - 在jdk7中，StringTable的长度默认值是60013，1009是可设置的最小值。

### String的内存分配

- 在Java语言中有8种基本数据类型和一种比较特殊的类型string。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。
- 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。
- 直接使用双引号声明出来的String对象会直接存储在常量池中。
    - 比如: String info = "atguigu.com" ;
- 如果不是用双引号声明的String对象，可以使用String提供的
    - intern()方法
- Java 6及以前，字符串常量池存放在永久代。
- Java 7中Oracle的工程师对字符串池的逻辑做了很大的改变，即*将**字符串常量池的位置调整到Java堆内***。
    - 所有的字符串都保存在堆(Heap)中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。
    - 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java 7中使用String.intern()。
- Java8元空间，字符串常量在堆

**StringTable为什么要调整？**

1. permSize默认比较小
2. 永久代垃圾回收频率低

### 字符串的拼接操作

1. 常量与常量的拼接结果在常量池，原理是编译期优化
2. 常量池中不会存在相同内容的常量。
3. 只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
4. 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。
    - intern()：判断字符串常量池中是否存在这个值，如果存在，则返回常量池中的地址，如果不存在，则再常量池中加载一个新的，并返回对象的地址
5. 字符串拼接操作不一定使用的是StringBuilder，如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译器优化，即非StringBuilder的方式。
6. **注意**：虽然编译器会将+号的拼接操作转换为StringBuilder，但是多次拼接会多次转换为StringBuilder，并不是一次，因此会很浪费时间和空间。

```java
public void test4(){
	final String s1 = "a";
	final String s2 = "b";
	String s3 = "ab";
	String s4 = S1 + s2;
	System. out.println(s3 == s4);//true
}
```



> 针对于final修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上final的时候建议使用上。



### intern()的使用

如果不是用双引号声明的String对象，可以使用String提供的intern方法: intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。



```java
String myInfo = new String("I love atguigu").intern();
```

也就是说，如果在任意字符串上调用String. intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true:

```java
("a" + "b" + "c").intern() == "abc" 
```

通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池(String Intern Pool) 。

**new String("ab")会创建几个对象？**

1. new关键字在堆空间创建的
2. 字符串常量池中的对象。字节码指令：ldc

**new String("a") + new String("b")呢？**

1. new Stringbuilder
2. new String("a")
3. 常量池中的 "a"
4. new String("b")
5. 常量池中的 "b"
6. toString(): new String("ab") 但是不在字符串常量池中生成 "ab"



**分析以下代码：**

```java
public class StringIntern {
    public static void main(String[] args) {
        String s = new String("1");
        s.intern(); // 调用前常量池中已有1
        String s2 = "1";
        System.out.println(s == s2); // jdk6、7、8 false
        
        String s3 = new String("1") + new String("1"); // s3变量的记录地址为 new String("11")
        // 调用前常量池中无11
        // 在常量池中生成11
        // jdk6 创建了一个新的对象11，也就有新的地址了
        // jdk7 此时常量中并没有创建11 而是创建了一个指向堆空间new String("11")的地址 
        // 为了节省空间的做法
        s3.intern();
        String s4 = "11"; // 使用的是常量池中11的地址 
        System.out.println(s3 == s4); // jdk6 fasle, jdk7/8 true
    }
}
```



**总结String的intern()的使用**

jdk1.6中， 将这个字符串对象尝试放入串池。

- 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
- 如果没有，会把此**对象复制一份**，放入串池，并返回串池中的对象地址

Jdk1.7起，将这个字符串对象尝试放入串池。

- 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
- 如果没有，则会把**对象的引用地址复制一份**， 放入串池，并返回串池中的引用地址

**intern()的空间效率测试**

```java
for (int i = 0; i < 10000; i++) {
	// 会不断创建new String对象
    arr[i] = new String(String.valueof(i % 10));
    // 虽然也创建了new对象，但是会被GC清理掉，更优
    arr[i] = new String(String.valueof(i % 10)).intern();
}
```

对于程序中大量存在的字符串，尤其其中存在的很多重复字符串，使用intern()可以节省内存空间



### G1的String去重操作

**背景**:对许多Java应用(有大的也有小的)做的测试得出以下结果:

- 堆存活数据集合里面String对象占了25%
- 堆存活数据集合里面重复的string对象有13.5%
- String对象的平均长度是45

许多大规模的Java应用的瓶颈在于内存，测试表明，在这些类型的应用里面，Java堆中存活的数据集合差不多25%是String对象。更进一步，这里面差不多一半string对象是重复的，重复的意思是说: string1.equals(string2)=true。堆上存在重复的String对象必然是一种内存的浪费。这个项目将在G1垃圾收集器中实现自动持续对重复的strinq对象进行去重，这样就能避免浪费内存。

**实现**

- 当垃圾收集器工作的时候，会访问堆上存活的对象。*对每一个访问的对象都会检查是否是候选的要去重的String对象*。
- 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。
- 使用一个hashtable来 记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable,来看堆上是否已经存在一个一模一样的char数组。
- 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。
- 如果查找失败，char数组会被插入到hashtable,这样以后的时候就可以共享这个数组了。