# 目录

[TOC]

# 基础

## 概述

## 数据库三大范式
　　第一范式（1NF）：字段不可分；原子性。 
　　第二范式（2NF）：有主键，非主键字段依赖主键，一个表只说明一个事物；
　　第三范式（3NF）：非主键字段不能相互依赖，每个字段都与主键有直接关系，不存在传递依赖。

## 数据类型
- date: 

    日期  如：2019-10-26 不带时分秒
    
    范围: '1000-01-01' to '9999-12-31'
- datetime: 

    日期时间 如：2019-10-26 10:53:00 带时分秒 
    
    范围: '1000-01-01 00:00:00' to '9999-12-31 23:59:59'.
- timestamp: 

    时间戳，见百度百科： 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数。
    
    范围: '1970-01-01 00:00:01' UTC to '2038-01-19 03:14:07' UTC 
    
    Coordinated Universal  Time，协调世界时，又称世界统一时间、世界标准时间、国际协调时间。由于英文（CUT）和法文（TUC）的缩写不同，作为妥协，简称UTC。
    
## 字符集

# 语法

## 库相关

## 表结构相关

## 表数据相关

# 索引
## 索引类型
MySQL索引分为普通索引、唯一索引、主键索引、组合索引、全文索引。索引不会包含有null值的列，索引项可以为null（唯一索引、组合索引等），但是只要列中有null值就不会被包含在索引中。

- 普通索引： 
    - create index index_name on table(column)；
    - 或者创建表时指定，create table(..., index index_name column);

- 唯一索引： 类似普通索引，索引列的值必须唯一（可以为空，这点和主键索引不同）
    - create unique index index_name on table(column)；
    - 或者创建表时指定unique index_name column

- 主键索引： 特殊的唯一索引，不允许为空，只能有一个，
    - 建表时指定primary key(column)

- 组合索引： 在多个字段上创建索引，遵循最左前缀原则。
    -alter table t add index index_name(a, b, c);

- 全文索引： 主要用来查找文本中的关键字，不是直接与索引中的值相比较，像是一个搜索引擎，配合match against使用，现在只有char，varchar，text上可以创建全文索引。在数据量较大时，先将数据放在一张没有全文索引的表里，然后再利用create index创建全文索引，比先生成全文索引再插入数据快很多。



## 索引使用
### 索引使用场景
- 主键，unique字段；
- 和其他表做连接的字段需要加索引；
- 在where里使用>，≥，＝，<，≤，is null和between等字段；
- 使用不以通配符开始的like，where A like 'China%'；
- 聚集函数MIN()，MAX()中的字段；
- order by和group by字段；

### 索引不使用场景
- 表记录太少；
- 数据重复且分布平均的字段（只有很少数据值的列）；
- 经常插入、删除、修改的表要减少索引；
- text，image等类型不应该建立索引，这些列的数据量大（假如text前10个字符唯一，也可以对text前10个字符建立索引）；
- MySQL能估计出全表扫描比使用索引更快时，不使用索引；

## 索引失效
- 组合索引未使用最左前缀，例如组合索引（A，B），where B=b不会使用索引；
- like未使用最左前缀，where A like '%China'；
- 搜索一个索引而在另一个索引上做order by，where A=a order by B，只使用A上的索引，因为查询只使用一个索引 ；
- or会使索引失效。如果查询字段相同，也可以使用索引。例如where A=a1 or A=a2（生效），where A=a or B=b（失效）
- 如果列类型是字符串，要使用引号。例如where A='China'，否则索引失效（会进行类型转换）；
- 在索引列上的操作，函数（upper()等）、or、！=(<>)、not in等；

# 事务

## ACID
事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性，通常简称为事务的ACID属性。 

- 原子性（Atomicity）

事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。

- 一致性（Consistent）

在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。 

- 隔离性（Isolation）

数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。 

- 持久性（Durable）

事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。

## 事务问题
- 更新丢失（lost update）
当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。
例如，两个程序员修改同一java文件。每程序员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖前一个程序员所做的更改。
如果在一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题。

- 脏读(事务没提交，提前读取dirty reads)

脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这
时，另外一个事务也访问这个数据，然后使用了这个数据。

- 不可重复读(两次读的不一致non-repeatable reads)

指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那
么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可
能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。例
如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取
文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，
则可以避免该问题。

- 幻读(phantom reads)

指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好像发生了幻觉一
样。例如，一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，
发现作者已将未编辑的新材料添加到该文档中。如果在编辑人员和生产部门完成对原始文档的处理之
前，任何人都不能将新材料添加到文档中，则可以避免该问题。

## 事务隔离级别

事务的隔离级别有读未提交（read uncommitted）、读已提交（read committed）、可重复读（repeatable read）和可序列化（serializable）四种。

| 隔离级别 | 读数据一致性                             | 脏读 | 不可重复读 | 幻读 |
| -------- | ---------------------------------------- | ---- | ---------- | ---- |
| 读未提交 | 最低级别，只能保证不读取物理上损坏的数据 | 是   | 是         | 是   |
| 读已提交 | 语句级                                   | 否   | 是         | 是   |
| 可重复读 | 事务级                                   | 否   | 否         | 是   |
| 可序列化 | 最高级别，事务级                         | 否   | 否         | 否   |

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。 
 
### 读未提交

### 读已提交

### 可重复读

### 可序列化

## 事务相关语法
查看当前数据库的事务隔离级别：
```mysql
show variables like 'tx_isolation';
```

查看隔离级别
```mysql
# 查看当前会话隔离级别
select @@tx_isolation;
# 查看系统当前隔离级别
select @@global.tx_isolation;
```

设置当前会话隔离级别
```mysql
set session transaction isolation level read uncommitted;
set session transaction isolation level read committed;
set session transaction isolation level repeatable read;
set session transaction isolation level serializable;
```

事务开启、提交和回滚
```mysql
# 开启事务
start transaction;
# 提交事务
commit;
# 回滚事务
rollback;
```

# 锁

# 引擎
## MyISAM

## InnoDB
MyISAM引擎是MySQL 5.1及之前版本的默认引擎，它的特点是：
- 不支持行锁，读取时对需要读到的所有表加锁，写入时则对表加排它锁
- 不支持事务
- 不支持外键
- 不支持崩溃后的安全恢复
- 在表有读取查询的同时，支持往表中插入新纪录
- 支持BLOB和TEXT的前500个字符索引，支持全文索引
- 支持延迟更新索引，极大提升写入性能
- 对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用

## 基础概念
InnoDB在MySQL 5.5后成为默认索引，它的特点是：
- 支持行锁，采用MVCC来支持高并发
- 支持事务
- 支持外键
- 支持崩溃后的安全恢复
- 不支持全文索引

# 优化
## 程序优化
- 创建表时字段类型在满足需求的情况下越小越好；
- 尽量将数据的处理工作放在服务器上，减少网络的开销
- 当服务器的内存够多时，配制线程数量 = 最大连接数+5，这样能发挥最大的效率；否则使用配制线程数量<最大连接数启用SQL SERVER的线程池来解决，如果还是数量 = 最大连接数+5，严重的损害服务器的性能；
- 当有一批处理的插入或更新时，用批量插入或批量更新，绝不会一条条记录的去更新

## 表设计优化
- 避免在创建表时NULL是默认值，然后在where子句中对字段进行null值判断，应该使用NOT NULL，或者用0作为默认值；
- 使用数字型字段，若只含数值信息的字段不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销；
- 使用varchar/nvarchar代替char/nchar，变长字段存储空间小，可以节省存储空间，而且在一个相对较小的字段内查询效率要高些；
- 将需要查询的结果预先计算好放在表中，查询的时候再Select

## 语法优化
- 尽量做单表查询，避免任何方式的多表查询；进行多表查询时可将连接（join）查询来代替子查询；
- sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库；
- 避免select *，将需要查找的字段列出来；
- 拆分大的delete或insert语句；
- 不用函数和触发器，在应用程序实现；
- 使用同类型进行比较，比如用'123'和'123'比，123和123比；

### 关键词相关
- OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内；
- 对于连续数值，使用BETWEEN不用IN；
- 列表数据不要拿全表，要使用LIMIT来分页限定，每页数量也不要太大；
- 可以通过将不需要的记录在GROUP BY之前过滤掉来提高GROUP BY语句的效率；
- 当只要一行数据时使用LIMIT 1；

### 运算符相关
- 不做列运算：SELECT id WHERE age + 1 = 10，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边；
- 尽量使用“>=”，不要使用“>”

## 索引优化
- 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描；
- 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描；

### 创建索引相关
- 值分布很稀少的字段不适合建索引，例如"sex"；
- 尽量不用UNIQUE，由程序保证约束；
- 索引的创建要与应用结合考虑，建议大的OLTP表不要超过6个索引；

### 关键词相关
- Like左模糊查询也会导致全表扫描；

### 运算符相关
- 尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描；
- 应尽量避免在where子句中使用or来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，可以使用UNION合并查询：


4.字符字段只建前缀索引
5.字符字段最好不要做主键
8.使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引

尽可能的使用索引字段作为查询条件，尤其是聚簇索引，必要时可以通过index index_name来强制指定索引；

避免对大表查询时进行table scan，必要时考虑新建索引；

在使用索引字段作为条件时，如果该索引是联合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用；

要注意索引的维护，周期性重建索引，重新编译存储过程。　
表的主键、外键必须有索引； 

数据量超过300的表应该有索引； 

经常与其他表进行连接的表，在连接字段上应该建立索引； 

经常出现在Where子句中的字段，特别是大表的字段，应该建立索引； 

索引应该建在选择性高的字段上； 

索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； 

复合索引的建立需要进行仔细分析，尽量考虑用单字段索引代替； 

正确选择复合索引中的主列字段，一般是选择性较好的字段； 

复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引； 

如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引； 

如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段； 

如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引； 

频繁进行数据操作的表，不要建立太多的索引； 

删除无用的索引，避免对执行计划造成负面影响； 

表上建立的每个索引都会增加存储开销，索引对于插入、删除、更新操作也会增加处理上的开销。另外，过多的复合索引，在有单字段索引的情况下，一般都是没有存在价值的；相反，还会降低数据增加删除时的性能，特别是对频繁更新的表来说，负面影响更大。 

尽量不要对数据库中某个含有大量重复的值的字段建立索引。

选择合适的数据类型
（1）使用可存下数据的最小的数据类型，整型 < date,time < char,varchar < blob
（2）使用简单的数据类型，整型比字符处理开销更小，因为字符串的比较更复杂。如，int类型存储时间类型，bigint类型转ip函数
（3）使用合理的字段属性长度，固定长度的表会更快。使用enum、char而不是varchar
（4）尽可能使用not null定义字段
（5）尽量少用text，非用不可最好分表# 

选择合适的索引列
（1）查询频繁的列，在where，group by，order by，on从句中出现的列
（2）where条件中<，<=，=，>，>=，between，in，以及like 字符串+通配符（%）出现的列
（3）长度小的列，索引字段越小越好，因为数据库的存储单位是页，一页中能存下的数据越多越好
（4）离散度大（不同的值多）的列，放在联合索引前面。查看离散度，通过统计不同的列值来实现，count越大，离散程度越高：

## 分区优化
MySQL在5.1版引入的分区是一种简单的水平拆分，用户需要在建表的时候加上分区参数，对应用是透明的无需修改代码

对用户来说，分区表是一个独立的逻辑表，但是底层由多个物理子表组成，实现分区的代码实际上是通过对一组底层表的对象封装，但对SQL层来说是一个完全封装底层的黑盒子。MySQL实现分区的方式也意味着索引也是按照分区的子表定义，没有全局索引

用户的SQL语句是需要针对分区表做优化，SQL条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，可以通过EXPLAIN PARTITIONS来查看某条SQL语句会落在那些分区上，从而进行SQL优化，我测试，查询时不带分区条件的列，也会提高速度，故该措施值得一试。

分区的好处是：
1.可以让单表存储更多的数据
2.分区表的数据更容易维护，可以通过清楚整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作
3.部分查询能够从查询条件确定只落在少数分区上，速度会很快
4.分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备
5.可以使用分区表赖避免某些特殊瓶颈，例如InnoDB单个索引的互斥访问、ext3文件系统的inode锁竞争
6.可以备份和恢复单个分区

分区的限制和缺点：
1.一个表最多只能有1024个分区
2.如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来
3.分区表无法使用外键约束
4.NULL值会使分区过滤无效
5.所有分区必须使用相同的存储引擎

分区的类型：
1.RANGE分区：基于属于一个给定连续区间的列值，把多行分配给分区
2.LIST分区：类似于按RANGE分区，区别在于LIST分区是基于列值匹配一个离散值集合中的某个值来进行选择
3.HASH分区：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL中有效的、产生非负整数值的任何表达式
4.KEY分区：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值
5.具体关于mysql分区的概念请自行google或查询官方文档，我这里只是抛砖引玉了。

## 分表优化
## 分库优化
# 实践

# 安装和卸载