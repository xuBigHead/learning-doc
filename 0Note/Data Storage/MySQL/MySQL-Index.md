# 目录

[TOC]



# 索引

索引有很多种类型，可以为不同的场景提供更好的性能。在 MySQL 中，**索引是存储引擎层实现的**，并没有统一的索引标准，即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。

索引的根本原理就是降低硬盘的io次数。



> 其实简单来说，索引就是一个排好序的数据结构



## 索引优势

1. 加快查询和分组、排序的速度，降低数据库的IO成本以及CPU的消耗。
2. 通过创建唯一索引，可以保证每一行数据的唯一性。
3. 加速表与表的连接。




## 索引劣势

1. 增删改操作时需要更新索引，会降低数据操作的性能：
  1. 新增：自然需要在索引树中新增节点；
  2. 删除：索引树中指向的记录可能会失效，意味着这棵索引树很多节点，都是失效的；
  3. 改动：索引树中节点的**指向**可能需要改变。
2. 创建索引时需要对表加锁，在锁表的同时，可能会影响到其他的数据操作。
3. 索引需要磁盘的空间进行存储，如果针对单表创建了大量的索引，可能比数据文件更快达到大小上限。
4. 当对表中的数据进行CRUD的时，也会触发索引的维护，而维护索引需要时间，可能会降低数据操作的性能。
5. 创建索引需要时间，后期创建的索引，创建开销时间与表数据量呈正相关



# 索引类型

## 数据结构角度

### B+Tree 索引

>  B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。最常见的索引类型，大部分索引都支持 B 树索引。



MySQL 中以 B+Tree 的有序的数据结构存储索引数据。

本身是一种平衡的二叉树，每一个叶子节点到根的距离都是相同的，并且记录的所有节点是按键值的大小、顺序放在同一层的叶子节点上的，并且每一个叶子节点是通过指针来连接的。

是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

B+Tree的每个非叶子节点存储了多个索引数据，每个非叶子节点大小为4kb。

MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个**指向相邻叶子节点的链表指针(整体类似一个双向链表的结构)**，就形成了带有顺序指针的B+Tree，提高区间访问的性能。



MyISAM的B+Tree索引的叶子节点上面存储的是主键id的内存地址。

MyISAM的B+Tree索引如果是主键，则叶子节点上面存储的是该主键对应的所有列；如果不是主键，则叶子节点上面存储的是主键数据。

自适应 HASH 索引：自动维护





#### 优点

Btree 索引适用于全值匹配的查询。如

Btree 索引适合处理范围查找。

Btee 索引从索引的最左侧列开始匹配查找列

对于多个列组合成的索引，只能从左开始查找，如



#### 缺陷

- 只能从最左侧开始按索引键的顺序使用索引，不能跳过索引键

    如一个 a_b_c 的联合索引，在过滤的时候使用 a 和 c 列，那么就只能用到 a 列的索引

- NOT IN 和 `<>`（不等于） 操作无法使用索引

- 索引列上不能使用表达式或是函数



#### 和B-Tree对比

- B+Tree的磁盘读写代价更低

B+Tree非叶子结点存储索引数据，仅仅包含索引列和地址指针，同一个结点（磁盘页）中，B+Tree包含的索引数量比B-Tree更多，同样的数据量下，B+Tree会比B-Tree更加“矮胖”，查询时需要的IO次数更少。



- B+树的查询效率更加稳定

B+Tree所有索引或行数据都在叶子结点，而叶子结点都属于同一层级，所有查询都是从根结点遍历到叶子结点，时间复杂度相比B-Tree查询更加稳定。



- B+树更有利对数据的扫描

B-Tree如果需要查询一串相邻的数值，可能需要来回扫描或是从根结点多次中序遍历。而B+Tree的所有元素都存储叶子结点，每个叶子结点都有指向下一个结点的指针，直接线性遍历即可。B+Tree更加利于做范围查询。



#### 扩展

##### 为什么索引结构默认使用B+Tree，而不是链表、hash、二叉树、红黑树？

- **HASH**

    虽然可以快速定位，但是没有顺序，IO复杂度高。

    

- **二叉树**

    树的高度不均匀，不能自平衡，查找效率跟树的高度有关，并且IO代价高。在极端情况下等同于链表，此时查询相当于全表扫描。

    

- **红黑树**

    树的高度不可控，随着数据量增加而增加，IO代价高。



##### 为什么官方建议使用自增长主键作为索引

结合B+Tree的特点，自增主键是连续递增的，在插入过程中能减少页分裂，即使要进行页分裂，也只会分裂很少一部分。并且能减少数据的移动，每次插入都是插入到最后。总之就是减少分裂和移动的频率。



##### B+Tree索引页能存储多少数据

一个索引页默认大小16kb，整数（`bigint`）字段的长度为8B，另外还跟着6B的指向其子树的指针，这意味着一个索引页可以存储接近1200条数据(16kb/14B ≈ 1170)。

- 树的根节点存储1200条索引目录，占用16kb内存。
- 树的第二层总共是1200个索引页，每个索引页存放1200条索引目录，就有144w条索引目录，占用1200 \* 16KB = 20M内存。
- 树的第三层1200 \* 1200 = 144w页，144w \* 16kB = 23G，此时不适合存放到内存中。



##### 根据主键ID查询流程

- 内存中直接获取树根索引页，对树根索引页内的目录进行二分查找，定位到第二层的索引页
- 内存中直接获取第二层的索引页，对索引页内的目录进行二分查找，定位到第三层的索引页
- 从磁盘加载第三层的索引页到内存中，对索引页内的目录进行二分查找，定位到第四层数据页
- 从磁盘加载第四层的数据页到内存中，数据页变成缓存页，对缓存页中的目录进行二分查找，定位到具体的行数据



### Hash索引

基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。



#### 优点

- 通过对Key进行散列值计算，可以直接得到对应数据的存放位置，它的查询效率能够达到O(1)。



#### 缺陷

- Hash索引仅仅能满足“=”，“in”查询条件，不能使用范围查询。
- 不能用部分索引键来搜索，因为组合索引在计算哈希值的时候是一起计算的。
- 哈希索引也没办法利用索引完成排序
- 不支持最左匹配原则
- 存在大量哈希冲突（Hash碰撞）的情况下，哈希索引的效率也是极低的


### R-Tree索引

空间索引，是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少。



## 主键角度

### 主键索引

MySQL在创建表时如果设置了主键（Primary Key），则会默认在主键列上设置索引，即主键索引（Primary Index）。



> 在InnoDB里，主键索引也被称为**聚簇索引**（Clustered Index）。



#### 特点

1. 数据唯一，不能为NULL



### 辅助索引

与主键索引相对的即是**辅助索引**（Secondary Index），辅助索引也被称为**二级索引**、**次级索引**。



## 应用层次角度

### 普通索引

即一个索引只包含单个列，一个表可以有多个单列索引。

普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。



### 组合索引

一个索引包含多个列。组合索引和字符串列上的索引都有一个最左匹配原则，查询条件中必须要有索引最左一列才会生效，而如果中间跳过一列则跳过的列及之后的列都不会生效。

有时有可能因为多个列名过长，导致组合索引树的键大小过大，降低了存储和查询的效率。所以为了避免出现这样的情况，可以适当的保证每一列的名字不要太长，或只取组合索引每一列前几个字符组成索引。

**组合索引实际还是一个索引，并非真的创建了多个索引，只是产生的效果等价于产生多个索引。**



**示例**

| 索引名称           | 字段               | 索引类型 | 索引方法 |
| ------------------ | ------------------ | -------- | -------- |
| idx_classify_title | classify_id, title | NORMAL   | BTREE    |



#### 优点

- 减少开销

组合索引(col1,col2,col3)实际产生的作用等价于建了(col1),(col1,col2),(col1,col2,col3)三个索引。索引也需要磁盘空间，每多一个索引，不仅增加磁盘空间的开销，还多了一棵索引的查询和维护。对于大量数据的表，使用联合索引会大大的减少磁盘空间和执行开销！



- 覆盖索引

如果查询的列都包括在组合索引中，那么MySQL可以只遍历一次该组合索引，便可以取到`col1,col2,col3`三列的数据，而无需回表，这就减少了很多IO操作。



- 效率高

索引列越多，通过索引筛选出的数据越少。



### 唯一索引

唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。

在数据库的角度中，`NULL` != `NULL` , 所以唯一索引列，可以有多个空值。

每张表可以有多个唯一索引，但是只能有一个Primary索引。



### 前缀索引

前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。



### 空间索引

> 不常用

空间索引，空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。



### 全文索引

> 不常用

全文索引（MySQL 5.6 之后InnoDB才支持），它是模糊匹配的一种更好的解决方案，它的效率要比使用`like %`更高，并且它还支持多种匹配方式，灵活性也更加强大。只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引。

全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引

全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。

说是全文索引，其实它只代表可以实现全文检索的功能，而全文检索的底层实现，实际就是倒排索引，所以你也可以把全文索引的本质，当做是倒排索引。再了解全文检索之前，务必要先了解倒排索引

为什么叫倒排索引？

因为英文单词Inverted有颠倒的意思，然后可能就被翻译为倒排索引，也有很多地方叫反向索引。相对而言的索引就是正排索引（forward index）
倒排索引和正排索引，我的个人理解是，它与我们之前说的B+索引，哈希索引的应用不同。拿这些索引的知识去理解正排索引和倒排索引，感觉有些难以联系起来，容易混乱。因为正排，倒排是属于搜索引擎范畴的概念，所以理解正排，倒排最好还是先对搜索引擎有一些了解。比如使用过ElasticSearch
什么是倒排索引（Inverted index）？

说实话，倒排索引也不是一个简单的概念，很多搜索引擎的底层原理都是倒排索引，比如ElasticSearch等。
学习倒排索引的时候，最好还是需要一些搜索引擎的知识会更容易理解。

倒排索引就是相对正排索引相反而言的模型。正排索引是通过文档ID来遍历文档内容，找到关键字（文档 -> 关键字）。而倒排索引则是通过关键字，找到所在的文档（关键字 -> 文档）

以上正排索引，假如我们的搜索引擎是基于正排索引实现的，那么我们要在索引库中查询"python"关键字, 就很可能需要一个一个文档的进行遍历，直到在某个文档的内容中找到"python"单词。这样的一个时间复杂度是很大的，尤其是数据量很大的情况下。所以基于正排索引实现的搜索引擎是不现实的

如果在每一文档录入搜索引擎索引库的时候，我们就对文档的内容进行分词，统计，分析。建立倒排索引，记录分词得到的每个单词对应文档的出现位置和出现次数。 那么我们在搜索引擎查询"python"关键字，就会非常的快速，只需要通过关键字就可以马上查询到已经预处理的统计分析结果。也就知道了'python'关键字在文档A和文档B出现过。展示给用户即可。

这也是为什么是正排和倒排的原因，正排是通过文档查找关键字，倒排是通过关键字查到对应的文档。详细的倒排索引知识以后有时间再在ES的知识点中重点说明。


## 数据存储角度

### 聚簇索引

聚簇索引（Clustered Index）又称`聚集索引`，将根据键值对数据库表中的数据进行排序存储，并将相关的信息聚簇在一起索引就叫聚簇索引（**该顺序是物理上连续的存储空间的顺序**）。

只有InnoDB支持聚簇索引，若存在主键，则以该主键列生聚簇索引树；若没有主键，则以**第一个唯一非空列**的索引作为聚簇索引；以上条件皆不满足，InnoDB会在内部生成一个名为`GEN_CLUST_INDEX`隐式聚簇索引。该索引是基于一个名为`DB_ROW_ID`的隐藏字段，通常称之隐式主键。



#### 特点

1. 定义了数据存储在表中的顺序，该表的数据有且仅以一种方式排序。因此，**每个表只能有一个聚簇索引**；
2. 聚簇索引其中一个大特征就是将索引和数据存储在同一个文件中，叶子结点不仅保存键的信息，还保存了位于同一行其他列的信息，**聚簇索引的叶子结点保存的是一个完整行记录数据**；
3. 聚簇索引是一种有序索引，它的具体实现可以是稠密索引，也可以是稀疏索引。



#### 优点

- **聚簇索引可以将相关的数据紧密的关联起来，存储在相邻的连续物理空间，利于范围查询**，比如将相关的数据存放在一个叶子结点上，既一个结点的多个关键字对应的数据都存储在一个数据页中，范围查询时，磁盘一次Load出即可，降低IO操作次数，比如针对MAX, MIN, COUNT等聚集函数都有很好的作用；

- **聚簇索引将数据和索引存储在同一个数据文件。** 既聚簇索引的叶子结点不仅存放键的信息，还存储相关其他列的完全数据。当查询走聚簇索引，不需要中间人跳转，直接就可以获得目的数据，查询效率更快。



#### 缺陷

- 因为聚簇索引是顺序存储的，如果多次的插入操作是以非顺序的方式执行，那么最终聚簇索引需要不断的维护这个顺序，这是需要一定性能消耗的；
- 当聚簇索引中的主键发生更改时，可能需要重新维护顺序，迫使物理空间的交换，所以聚簇索引需要更长的时间来更新记录；
- 支持聚簇索引的存储引擎的辅助键索引的查询结果只是一个中间结果，还需要通过中间结果到聚簇索引上二次查询，即回表，操作相对繁琐。



#### 扩展

##### 为什么InnoDB存储引擎一定要有聚簇索引呢？

如果SQL条件是一个非主键列的数据，那么在索引查询中，很可能需要跨树查询，既两次查询。

因为InnoDB的辅助索引的叶子结点并不存储行数据，而是对应的主键值。查询时需要根据辅助键索引查询到的主键值，再去聚簇索引中查询。



### 非聚簇索引

非聚簇索引（No-Clustered Index）将数据存储在一个位置，将索引存储在另一个位置，索引包含指向该数据位置的指针。



#### 特点

1. 一个表中可以包含多个非聚簇索引；
2. InnoDB的辅助键索引，以及MyISAM的主、辅索引都是非聚簇索引；
3. 非聚簇索引只存储键与指针，不存储数据，所以非聚簇索引的叶子结点仅保存数据的地址(`MyISAM`)或是其主键信息(`InnoDB`)。



#### 优点

- **因为一张表只能有一个聚簇索引，而非聚簇索引则可以有多个**；
- **非聚簇索引占用空间小**，因为叶子结点不存储真实数据，所以非聚簇索引相比聚簇索引更小；
- 在部分查询中，**可以利用覆盖索引的特性，加快查询速度**，直接从辅助键索引中获得想要的数据，而不需要做二次查询；
- **非聚簇索引只需要一次遍历，便可得到数据地址。**支持聚簇索引的存储引擎会导致其辅助键索引查询的结果只是一个中间结果，还需要通过该中间结果在聚簇索引再遍历一次。而不支持聚簇索引的存储引擎，只有非聚簇索引，非聚簇索引只需要一次遍历，即可得到真实数据的地址。



#### 缺陷

1. 非聚集索引只能按逻辑顺序存储数据，并不允许以物理空间连续的方式对数据行进行顺序存储。既非聚簇索引一个叶子结点内部的所有关键字仅仅是逻辑顺序的维护。一个结点对应真实数据在数据文件中可能并非按连续物理空间存储的。 相对聚簇索引的查询，IO次数可能更多，查询性能更低；
2. 相比聚簇索引，范围查询更慢，因为聚簇索引的范围查询可以让磁盘一次load出整个结点的数据线性遍历。虽然非聚簇索引的同叶子结点之间的关键字也是逻辑顺序存储，也可以线性遍历，但每线性遍历一个关键字都需要中间再跳转到另一个地方(InnoDB下的聚簇索引)遍历或(MyISAM下的数据文件)访问 。这个中间过程实际都是不同的IO操作，可能触发磁盘不同盘块的数据读取。所以本质还是会造成大量的IO操作；
3. 每当聚簇索引的主键值更新时，可能会触发非聚簇索引的更新，因为非聚簇索引的叶子结点可能存放的是主键信息（比如InnoDB）；
4. 每当数据文件中的数据发生更新时, 也可能会触发非聚簇索引的更新，因为可能会导致非聚簇索引叶子结点的数据地址发生改变（比如MyISAM）。



## 索引密度角度
### 稠密索引

稠密索引（Dense Index）是有序的，包含所有数据对应的索引，索引数据包含关键字段值和指向数据的指针。

>**Dense Index :**
>
>- An index record appears for every search key value in file.
>- This record contains search key value and a pointer to the actual record.



#### 特点

- 稠密索引的真实数据是按顺序储存的；
- 为每一个键都创建一个索引记录；
- 每个索引记录都包含键本身和指向实际数据的指针；
- 因为每个键都有索引，所以可以直接通过索引就找到目的键对应的数据。



### 稀疏索引

稀疏索引（Sparse Index）是有序的，包含部分数据对应的索引，索引数据包含关键字段值和指向数据的指针。

>**Sparse Index :**
>
>- Index records are created only for some of the records.
>- To locate a record, we find the index record with the largest search key value less than or equal to the search key value we are looking for.
>- We start at that record pointed to by the index record, and proceed along the pointers in the file (that is, sequentially) until we find the desired record.



#### 特点

- 稀疏索引的真实数据是按顺序存储的；
- 只为部分的键创建索引记录；
- 当在稀疏索引中查找某个目的键时，通常会通过索引，先找到小于或等于目的键的其他键的数据项，既通过索引找到比目的键值要小的数据项（如果目的键有索引，就直接找到目的键的数据）。然后在数据项按顺序遍历(线性)，直到找到目的键的数据记录。



#### 稠密索引和稀疏索引的优缺点

- 相对某列键而言，稠密索引对每个数据都建有索引，要查询起来，直接快速。但是因为要为每个数据都建立对应的索引，所以需要比较大的空间资源
- 而稀疏索引因为只针对部分数据建立索引，所以空间资源占用小，但是查询效率相对比较慢

# 存储引擎支持

## 数据结构角度

| 索引        | INNODB                               | MYISAM | MEMORY | HEAP | NDB  |
| ----------- | ------------------------------------ | ------ | ------ | ---- | ---- |
| BTREE索引   | 支持                                 | 支持   | 支持   |      |      |
| HASH 索引   | 不支持<br />（支持自适应的HASH索引） | 不支持 | 支持   | 支持 | 支持 |
| R-tree 索引 | 不支持                               | 支持   | 不支持 |      |      |



## 主键角度

| 索引     | INNODB引擎 | MYISAM引擎 | MEMORY引擎 |
| -------- | ---------- | ---------- | ---------- |
| 主键索引 | 支持       | 支持       | 支持       |
| 辅助索引 | 支持       | 支持       | 支持       |



## 应用层次角度

| 索引               | INNODB引擎      | MYISAM引擎 | MEMORY引擎 |
| ------------------ | --------------- | ---------- | ---------- |
| 全文索引(FULLTEXT) | 5.6版本之后支持 | 支持       | 不支持     |



## 数据存储角度

| 索引       | INNODB引擎 | MYISAM引擎 | MEMORY引擎 |
| ---------- | ---------- | ---------- | ---------- |
| 聚簇索引   | 支持       | 不支持     | ？         |
| 非聚簇索引 | 支持       | 支持       | ？         |



# 索引的维护

## B+Tree索引

B+Tree索引是一个有序的树形结构，因此每次增删改涉及到索引的数据时，都会对索引的数据页和索引页进行重新排列（回收和分裂）。



> 删除操作并不会立即进行数据页内记录的重排列，而是会给被删除的记录打上一个删除的标识，等到合适的时候，再把记录从链表中移除，但是总归需要涉及到排序的维护，势必要消耗性能。





# 最佳实践

## 正确姿势

### 离散度高的列

离散度公式：`COUNT(DISTINCT(column_name)) / COUNT(*)`，列的不重复值的个数与所有数据行的比例。简而言之，如果列的重复值越多，列的离散度越低。重复值越少，离散度就越高。

为离散度高的列创建索引时会在二级索引中搜索到大量的重复数据，然后进行大量回表操作。



### 搜索、排序或分组的列

只为出现在`WHERE`子句中的列或者出现在`ORDER BY`和`GROUP BY`子句中的列创建索引即可。仅出现在查询列表中的列不需要创建索引。



### 联合索引

**不要为联合索引的第一个索引列单独创建索引**，因为联合索引本身就是先按照第一个索引列进行排序，因此联合索引对第一个索引列的搜索是有效的，不需要单独为`name`再创建索引了。

因此在建立联合索引的时候，要注意如下几点：

1. 区分度最高的列放在联合索引的最左侧
2. 使用最频繁的列放到联合索引的最左侧
3. 尽量把字段长度小的列放在联合索引列的最左侧



### 过长的列

如果一个字符串格式的列占用的空间比较大（就是说允许存储比较长的字符串数据），为该列创建索引，就意味着该列的数据会被完整地记录在每个数据页的每条记录中，会占用相当大的存储空间。

对此，可以为该列的前几个字符创建索引，也就是在二级索引的记录中只会保留字符串的前几个字符。比如可以为`phone`列创建索引，索引只保留手机号的前3位：

```sql
ALTER TABLE user_innodb ADD INDEX IDX_PHONE_3 (phone(3));
```

然后执行下面的SQL语句：

```sql
EXPLAIN SELECT * FROM user_innodb WHERE phone = '1320';
```

由于在`IDX_PHONE_3`索引中只保留了手机号的前3位数字，所以我们只能定位到以132开头的二级索引记录，然后在遍历所有的这些二级索引记录时再判断它们是否满足第4位数为0的条件。



**当列中存储的字符串包含的字符较多时，为该字段建立前缀索引可以有效节省磁盘空间**。



### 较短的列

索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。



## 错误姿势
### 索引越多越好

不是越多越好，维护也需要时间和空间代价，建议单张表索引不超过 5 个。



#### 空间上的代价

索引就是一棵B+数，每创建一个索引都需要创建一棵B+树，每一棵B+树的节点都是一个数据页，每一个数据页默认会占用16KB的磁盘空间，每一棵B+树又会包含许许多多的数据页。所以，大量创建索引会消耗大量磁盘空间。



#### 时间上的代价

MySQL 执行优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。

数据更新时会维护过多索引导致效率降低。



### 数据量小的表建立索引

数据量过小，建索引等于多此一举，还增加了操作复杂度。



### 频繁更新的列

数据频繁更新，触发索引频频维护（数据页回收和分裂），降低写速度。



### 随机无序的列

随机无序的值，不建议作为索引，例如身份证、UUID。



## 索引失效

现有如下联合索引：

| 名                 | 字段               | 索引类型 | 索引方法 |
| ------------------ | ------------------ | -------- | -------- |
| idx_classify_title | classify_id, title | NORMAL   | BTREE    |
| uk_url             | url                | UNIQUE   | BTREE    |



### 最左前缀原则

MySQL根据联合索引查询时，会按从左往右的字段依次进行排序查询。查询条件中的字段依次匹配上索引字段，就能根据对应的索引查询，如果中间有中断，没有匹配上，则从中断位置及后面的索引字段都无法根据索引查询。

因此如果联合索引最左边的字段没有匹配上，则不会根据该联合索引进行查询。



#### 错误用法

```mysql
SELECT * FROM `it_blog` WHERE `title` LIKE '异常设计%';
```

执行计划如下：

| id   | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :------ | :--------- | :--- | :------------ | :--- | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1995 | 11.11    | Using where |



联合索引的B+树数据页内的记录首先按照 `classify_id` 字段进行排序，`classify_id` 字段相同的情况下，再按照 `title` 字段进行排序。所以，如果我们直接使用 `title` 字段进行搜索，无法利用索引的顺序性。



#### 正确用法

```mysql
SELECT * FROM `it_blog` WHERE `title` LIKE '异常设计%' AND `classify_id` = 1;
```

执行计划如下：

| id   | select_type | table   | partitions | type  | possible_keys      | key                | key_len | ref  | rows | filtered | Extra                 |
| :--- | :---------- | :------ | :--------- | :---- | :----------------- | :----------------- | :------ | :--- | :--- | :------- | :-------------------- |
| 1    | SIMPLE      | it_blog | NULL       | range | idx_classify_title | idx_classify_title | 1030    | NULL | 1    | 100.00   | Using index condition |



加上 `classify_id` 的搜索条件，就会使用到联合索引，而且不需要在意 `classify_id` 在 `WHERE` 子句中的位置，因为查询优化器会进行优化。



### 使用反向查询（!=, <>,NOT LIKE）

MySQL在使用反向查询（!=, <>, NOT LIKE）的时候无法使用索引，会导致全表扫描，覆盖索引除外。



#### 错误用法

```mysql
SELECT * FROM `it_blog` WHERE `classify_id` <> 1;
```

执行计划如下：

| id   | select_type | table   | partitions | type | possible_keys      | key  | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :------ | :--------- | :--- | :----------------- | :--- | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog | NULL       | ALL  | idx_classify_title | NULL | NULL    | NULL | 1995 | 50.38    | Using where |

查询 `classify_id` 不为1的数据时，MySQL会进行全表扫描，获取所有的数据。



#### 正确用法

```mysql
SELECT `id`, `classify_id` FROM `it_blog` WHERE `classify_id` <> 1;
```

执行计划如下：

| id   | select_type | table   | partitions | type  | possible_keys      | key                | key_len | ref  | rows | filtered | Extra                    |
| :--- | :---------- | :------ | :--------- | :---- | :----------------- | :----------------- | :------ | :--- | :--- | :------- | :----------------------- |
| 1    | SIMPLE      | it_blog | NULL       | range | idx_classify_title | idx_classify_title | 8       | NULL | 1005 | 100.00   | Using where; Using index |

同样查询 `classify_id` 不为1的数据时，但由于此时查询的所有数据都在索引页中，因此MySQL会进行优化，在索引页中进行查询，而不是全表扫描。



#### 主键<>查询

```mysql
SELECT * FROM `it_blog` WHERE `id` <> 1
```

执行计划如下：

| id   | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :------ | :--------- | :---- | :------------ | :------ | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL | 1057 | 100.00   | Using where |

在主键反向查询这种特殊的场景下，也是能够使用主键索引的。



### LIKE以通配符开头

在进行LIKE模糊匹配时，如果匹配条件中的通配符在左边，则无法使用索引查询。因为字符串的模糊匹配和联合索引类似，也是从左往右将字符串中的字符依次匹配，如果通配符在左边，就无法匹配最左边的字符，因此会导致索引失效。

和反向查询一样，覆盖索引除外，因为所有数据都可以在索引页中获取。



#### 错误用法

```mysql
SELECT * FROM `it_blog` WHERE `url` LIKE '%https://blog.csdn.net%';
SELECT * FROM `it_blog` WHERE `url` LIKE '%https://blog.csdn.net';
```

执行计划如下：

| id   | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :------ | :--------- | :--- | :------------ | :--- | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 1995 | 11.11    | Using where |



当使用 `url LIKE '%https://blog.csdn.net'` 或者 `url LIKE '%https://blog.csdn.net%'` 这两种方式都会使索引失效，因为联合索引的B+树数据页内的记录首先按照 `url ` 字段进行排序，这两种搜索方式无法从 `url ` 字段最左边开始匹配，自然就无法使用索引，只能通过全表扫描的方式进行查询。



#### 正确用法

```mysql
SELECT * FROM `it_blog` WHERE `url` LIKE 'https://blog.csdn.net%';
SELECT * FROM `it_blog` WHERE `url` LIKE 'https://blog.csdn.net';
```

执行计划如下：

| id   | select_type | table   | partitions | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                 |
| :--- | :---------- | :------ | :--------- | :---- | :------------ | :----- | :------ | :--- | :--- | :------- | :-------------------- |
| 1    | SIMPLE      | it_blog | NULL       | range | uk_url        | uk_url | 1022    | NULL | 9    | 100.00   | Using index condition |



模糊匹配通配符不在左边时就可以使用索引，根据 `url` 字段从最左边开始匹配从索引页中获取数据。



### 对索引列做任何操作

如果不是单纯使用索引列，而是对索引列做了其他操作，例如数值计算、使用函数、（手动或自动）类型转换等操作，会导致索引失效。



#### 使用函数

##### 错误用法

```mysql
SELECT * FROM `it_blog` WHERE LEFT(`url`, 24) = 'https://mp.weixin.qq.com';
```

执行计划如下：

| id   | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :------ | :--------- | :--- | :------------ | :--- | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2020 | 100.00   | Using where |



因为对索引字段 `url` 做了函数操作，导致索引失效。



##### 正确用法

```mysql
SELECT * FROM `it_blog` WHERE `url` LIKE 'https://mp.weixin.qq.com%';
```

执行计划如下：

| id   | select_type | table   | partitions | type  | possible_keys | key    | key_len | ref  | rows | filtered | Extra                 |
| :--- | :---------- | :------ | :--------- | :---- | :------------ | :----- | :------ | :--- | :--- | :------- | :-------------------- |
| 1    | SIMPLE      | it_blog | NULL       | range | uk_url        | uk_url | 1022    | NULL | 402  | 100.00   | Using index condition |



#### 使用表达式

##### 错误用法

```mysql
SELECT * FROM `it_blog` WHERE `id` + 1 = 2;
```

执行计划如下：

| id   | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :------ | :--------- | :--- | :------------ | :--- | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2020 | 100.00   | Using where |



因为在主键id查询时，对id字段使用了表达式，导致索引时效。



##### 正确用法

```mysql
SELECT * FROM `it_blog` WHERE `id` = 2 - 1;
```

执行计划如下：

| id   | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
| :--- | :---------- | :------ | :--------- | :---- | :------------ | :------ | :------ | :---- | :--- | :------- | :---- |
| 1    | SIMPLE      | it_blog | NULL       | const | PRIMARY       | PRIMARY | 8       | const | 1    | 100.00   | NULL  |



#### 使用类型转换

##### 错误用法

```mysql
SELECT * FROM `it_blog_classify` WHERE `title` = 3;
```

​	执行计划如下：

| id   | select_type | table            | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :--------------- | :--------- | :--- | :------------ | :--- | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog_classify | NULL       | ALL  | idx_title     | NULL | NULL    | NULL | 10   | 10.00    | Using where |



使用整型条件查询索引字段 `title` 时，由于会发生类型转换，导致无法使用索引。



##### 正确用法

```mysql
SELECT * FROM `it_blog_classify` WHERE `title` = '3';
```

执行计划如下：

| id   | select_type | table            | partitions | type  | possible_keys | key       | key_len | ref   | rows | filtered | Extra |
| :--- | :---------- | :--------------- | :--------- | :---- | :------------ | :-------- | :------ | :---- | :--- | :------- | :---- |
| 1    | SIMPLE      | it_blog_classify | NULL       | const | idx_title     | idx_title | 1022    | const | 1    | 100.00   | NULL  |



```mysql
SELECT * FROM `it_blog_classify` WHERE `id` = '3';
SELECT * FROM `it_blog_classify` WHERE `id` = 3;
```

执行计划如下：

| id   | select_type | table   | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
| :--- | :---------- | :------ | :--------- | :---- | :------------ | :------ | :------ | :---- | :--- | :------- | :---- |
| 1    | SIMPLE      | it_blog | NULL       | const | PRIMARY       | PRIMARY | 8       | const | 1    | 100.00   | NULL  |



因此当索引字段类型为字符串时，使用数字类型进行搜索不会用到索引；而索引字段类型为数字类型时，使用字符串类型进行搜索会使用到索引。



##### 原理解析

MySQL遇到类型转换时，会自动将字符串类型转换为数字类型。

```mysql
SELECT 10 > 9 # result 1
SELECT '10' > 9 # result 1
SELECT '10' > '9' # result 0
```

如上所示，在比较字符串类型10和数字类型9的大小时，结果与数字类型10和数字类型9的比较结果一致。因此可以得知MySQL在字符串类型比较数字类型时，会将字符串类型转换为数字类型。



```mysql
SELECT * FROM `it_blog_classify` WHERE `title` = 3;
# 等价于
SELECT * FROM `it_blog_classify` WHERE CAST(`title` AS signed int) = 3;
```

使用数字类型查询字符串类型字段时，因为在索引字段使用了函数，导致索引失效。



```mysql
SELECT * FROM `it_blog_classify` WHERE `id` = '3';
# 等价于
SELECT * FROM `it_blog_classify` WHERE `id` = CAST('3' AS signed int);
```

使用字符串类型查询数字类型字段时，没有在索引字段添加任何操作，因此不会导致索引失效。



### OR连接

`OR` 查询时只有条件两边字段都走索引才不会发生索引失效。



#### 错误用法

```mysql
SELECT * FROM `it_blog` WHERE `tag_id` = 1 OR `classify_id` = 1
```

执行计划如下：

| id   | select_type | table   | partitions | type | possible_keys      | key  | key_len | ref  | rows | filtered | Extra       |
| :--- | :---------- | :------ | :--------- | :--- | :----------------- | :--- | :------ | :--- | :--- | :------- | :---------- |
| 1    | SIMPLE      | it_blog | NULL       | ALL  | idx_classify_title | NULL | NULL    | NULL | 2112 | 39.70    | Using where |

因为OR查询时，只有 `classify_id` 字段有索引，而 `tag_id` 字段没有设置索引，所以SQL执行了全表扫面。



#### 正确用法

```mysql
SELECT * FROM `it_blog` WHERE `user_id` = 1 OR `classify_id` = 1;
```

执行计划如下：

| id   | select_type | table   | partitions | type        | possible_keys                            | key                                      | key_len | ref  | rows | filtered | Extra                                                        |
| :--- | ----------- | ------- | ---------- | ----------- | ---------------------------------------- | ---------------------------------------- | ------- | ---- | ---- | -------- | ------------------------------------------------------------ |
| 1    | SIMPLE      | it_blog | NULL       | index_merge | idx_user_tag_classify,idx_classify_title | idx_user_tag_classify,idx_classify_title | 8,8     | NULL | 6    | 100.00   | Using sort_union(idx_user_tag_classify,idx_classify_title); Using where |

因为 `user_id` 和 `classify_id` 字段都设置了索引，因此没有发生索引失效，而实根据两个索引条件去查询数据。



# 查看索引使用情况

```sql
-- 查看当前会话索引使用情况
show status like 'Handler_read%';
-- 查看全局索引使用情况
show global status like 'Handler_read%';
```

**Handler_read_first**：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。

**Handler_read_key**：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。

**Handler_read_next** ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。

**Handler_read_prev**：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。

**Handler_read_rnd** ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。

**Handler_read_rnd_next**：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。