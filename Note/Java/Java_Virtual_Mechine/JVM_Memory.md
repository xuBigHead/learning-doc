# 运行时数据区

## 内存划分

内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。只要计算机在运行中，CPU就会把需要运算的数据调到内存中进行运算，当运算完成后CPU再将结果传送出来。所谓Java内存结构就是指Java虚拟机中对于内存的划分。

- 类加载系统：负责从文件系统或者网络加载class信息，加载的信息存放在方法区。   
- 直接内存：JAVA NIO库允许JAVA程序直接内存，从而提高性能，通常直接内存性能高于JAVA堆。读写频繁的场合可能会考虑使用。   
- 本地方法栈：本地方法栈和JAVA栈类似，最大的不同为本地方法栈用于本地方法调用。JAVA虚拟机允许JAVA直接调用本地方法。    
- 垃圾回收系统：是JAVA的核心。       
- pc寄存器：每个线程私有的空间。JAVA虚拟机为每个线程创建pc寄存器，在任意时刻一个JAVA线程总是在执行一个方法，这个方法被称为当前方法，如果当前方法不是本地方法，pc寄存器总会执行当前正在被执行的指令，如果是本地方	法，则pc寄存器值为 undefined，寄存器存放当前执行执行环境指针、程序技术器、操作栈指针、计算的变量指针等信息。  
- 执行引擎：虚拟机的核心组件，负责执行虚拟机的字节码，一般先编译成机器码后执行。
- JAVA内存模型：（共享内存模型JMM）定义了一个线程对另一个线程可见。共享变量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据时，可能本地内存没有及时刷新到主内存，所以就会发生线程安全问题。



## 对象的创建流程

1. 通过new创建一个类的实例化（类中只有属性和方法）；
2. 判断常量池中是否有对应的类符号引用，如果没有，则执行类的加载过程；如果有，再检查该符号引用所代表的类是否已被加载、解析和初始化过；
3. 虚拟机在堆中为对象分配内存，所需大小在类加载完成后便可完全确定（分配方式：指针碰撞和空闲列表）。类加载时会在栈中给属性，方法的引用分配内存，但是不会给局部变量分配内存空间，因为方法此时没有调用就没有执行，也就不会创建局部变量；
4. 将分配到的内存空间都初始化为零值，不包括对象头（基本类型的初始化）；
5. 对对象头（Object Header)进行设置，如对象哈希码，GC分代年龄等；
6. 调用对象的<init>方法（代码块和构造方法）；



在JVM在堆中为对象分配内存阶段，通常有以下两种分配方式，虚拟机选择哪种分配方式是由JAVA堆是否规整决定的，而JAVA堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

- 指针碰撞

要求堆中内存绝对规整，所有用过的内存都放一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅只是将该指针向空闲空间那边挪动一段与对象大小相等的距离。

- 空闲列表

针对的是堆中内存不规整的情况，虚拟机维护着一个列表，记录哪些内存块是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。



在为对象分配内存时，还需要考虑的一点就是线程安全性问题。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。针对这种问题，有以下两种解决方案。

- 对分配内存空间的动作进行同步处理，保证更新操作的原子性（采用CAS + 失败重试机制保障原原子性），但效率较低。

- 使用本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并需要分配新的TLAB时，才需要同步锁定（可通过-XX:+/-UseTLAB参数来设定虚拟机启用TLAB）。

在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头、实例数据和对齐填充。
对象头，由 Mark Word 和类型指针所组成。

Mark Word，用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等。

Mark Word在32位的JVM中对应的长度是32bit，在64位的JVM中长度是64bit。由于对象需要存储的运行数据很多，其实已经超出了32位和64位的限制，为了在极小的空间内存储尽量更多的信息，Mark Word 会根据对象状态的不同来存储不同的信息。如在32位的HotSpot虚拟机中，如对象处于未被锁定的状态，那么 Mark Word 将使用25bit用于存储对象的哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0。

类型指针，虚拟机通过这个指针来确定对象是哪个类的实例，该指针指向对象的类元数据。（由于查找对象的元数据信息并不一定要经过对象本身，所以并不是所有的虚拟机实现都必须在对象数据上保留类型指针）
如果对象是一个JAVA数组，那么在对象头中还必须有一块用于记录数组长度的数据，因为普通对象的大小可通过元数据信息来获取，而数组不行。

实例数据，对象真正存储的有效信息，也就是在代码中所定义+的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。存储顺序受虚拟机分配策略参数（FieldsAllocationStyle）和字段在java源码中定义顺序的影响。

HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)，相同带宽的字段总是被分配到一起，在此之后，父类中定义的变量会出现在子类之前。

如果CompactFields参数的值为true（默认为true），那么子类中较窄的变量也可能会插入到父类变量的空隙中。
对齐填充，无特殊含义，仅仅起到占位符的作用。HotSpot虚拟机要求起始地址必须是8字节的整数倍，因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

## JVM内存分区

基本数据类型比变量和对象的引用都是在栈分配的。

堆内存用来存放由new创建的对象和数组。

类变量（static修饰的变量），程序在一加载的时候就在堆中为类变量分配内存，堆中的内存地址存放在栈中。

实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存。

局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放。



- 程序计数器(寄存器)：当前线程所执行的字节码行号指示器
- 本地方法栈：同虚拟机栈，只不过本地方法栈为虚拟机使用到的native方法服务。
- 虚拟机栈：每个方法在执行的同时都会创建一个栈帧用来存放存储局部变量表、操作数表、动态连接、方法出口等信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
- 堆：所有线程共享的一块内存区域。Java虚拟机所管理的内存中最大的一块，因为该内存区域的唯一目的就是存放对象实例。几乎所有的对象实例度在这里分配内存，也就是通常我们说的new对象，同时堆也是垃圾收集器管理的主要区域。
- 方法区：和堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、和编译器即时编译后的代码等

首先栈、堆与方法区都是在内存中的，都是属于运行时数据区，读入了内存才能被称作运行时。
栈是运行时的单位，而堆是存储的单位。



### 堆
JVM中堆（Heap）用于存储对象，内存较大，线程共享，会抛出 OutOfMemoryError: Java heap space。

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，



=========
VM 中堆（Heap）（线程共享区）和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

堆内存分为两部分, 一部分是方法区, 另外一部分称为GC区。
Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域。在虚拟机启动的时候创建，在此区域的唯一目的就是存放对象实例，几乎所有的对象实例都是在这里分配内存，但是这个对象的引用却是在栈（Stack）中分配。因此，执行String s = new String("s")时，需要从两个地方分配内存：在堆中为String对象分配内存，在栈中为引用（这个堆对象的内存地址，即指针）分配内存。
堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”，如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError，可通过参数 -Xmx -Xms 来指定运行时堆内存的大小。

JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。

**概述**

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。
    - 堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local Allocation Buffer， TLAB) 。
- 《Java虚拟机规范》中对Java堆的描述是:所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the run-time data area from which memory for all class instances and arrays is allocated )
    - 我要说的是:“几乎” 所有的对象实例都在这里分配内存。从实际使用角度看的。
- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 堆，是GC ( Garbage Collection，垃圾收集器)执行垃圾回收的重点区域。



> 通过new关键字，创建对象都会使用堆内存



**内存细分**

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：



**设置参数**

1. Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项"`-Xmx`"和" `-Xms`"来进行设置。

    “`-Xms`"用于表示堆区的起始内存，等价于`-XX: InitialHeapSize`
    “`-Xmx`"则用于表示堆区 的最大内存，等价于`-XX :MaxHeapSize`

    一旦堆区中的内存大小超过“`-Xmx`”所指定的最大内存时，将会抛出OutOfMemoryError异常。

2. 通常会将`-Xms` 和`-Xmx`两个参数**配置相同的值**，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

3. 默认情况下，初始内存大小:物理电脑内存大小/64

    最大内存大小:物理电脑内存大小/4

4. 查看设置的参数：

    - 方式一：jps / jstat -gc 进程id
    - 方式二：-XX:+PrintGCDetails

**年轻代与老年代**

- 存储在JVM中的Jaya对象可以被划分为两类:
    - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
    - 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
- Java堆区进一步细分的话， 可以划分为年轻代(YoungGen) 和老年代(OldGen)
- 其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间(有时也叫做from区、to区)
- 新生代与老年代的比例：NewRatio 默认是1:2
- Eden与survivor区的比例：SurvivorRatio默认是8:1:1
- 几乎所有的对象都是在Eden区被new出来
- 绝大部分的Java对象的销毁都在新生代进行了



**图解对象分配过程**

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中停生内存碎片。

1. new的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC)，将伊甸园区中的不再被其他对象所引用的对象进行销毁。
3. 再加载新的对象放到伊甸园区然后将伊甸园中的剩余对象移动到幸存者0区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区.
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
6. 啥时候能去养老区呢?可以设置次数。默认是15次。
    可以设置参数: `-XX :MaxTenudingThreshold=<N>`进行设置。
7. 关于垃圾回收：频繁在新生区收集，很少在养老区收集，几乎不在永久区\元空间收集



**内存分配策略**

针对不同年龄段的对象分配原则如下所示:

- 优先分配到Eden
- 大对象直接分配到老年代
    - 尽量避免程序中出现过多的大对象
- 长期存活的对象分配到老年代
- 动态对象年龄判断
    - 如果Survivor 区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

- 空间分配担保
    - -XX: HandlePromotionFailure



**TLAB（Thread Local Allocation Buffer）**

> 为对象分配内存

**为什么需要TLAB？**

- 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
- 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
- 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。

**定义**

- 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。
- 多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为**快速分配策略**。
- 所有OpenJDK衍生出来的JVM都提供了TLAB的设计。



**说明**

- 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但*JVM确实是将TLAB作为内存分配的首选*。
- 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。
- 默认情况下，TLAB空间的内存非常小，*仅占有整个Eden空间的1%*，当然我们可以通过选项“-XX :TLABWasteTargetPercent"设置TLAB空间所占用Eden空间的百分比大小。
- 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。



**堆是分配对象存储的唯一选择吗？**

在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述:

随着JIT编译期的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换优化**技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。

在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是**如果经过逃逸分析(Escape Analysis) 后发现，一个对象并没有逃逸出方法的话，那么就可能被优化成栈上分配**。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的堆外存储技术。

此外，前面提到的基于openJDK深度定制的TaoBaoVM，其中创新的GCIH (GC invisible heap)技术实现off-heap，将生命周期较长的Java对象从heap中移至heap外，并且GC不能管理GCIH内部的Java对象，以此达到降低Gc的回收频率和提升GC的回收效率的目的。

**逃逸分析**

如何将堆上的对象分配到栈，需要使用逃逸分析手段。

- 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
- 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域

- 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
- 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

> 能使用局部变量的，就不要使用在方法外定义

**使用逃逸分析，编译器可以对代码做如下优化:**

1. *栈上分配*。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

2. *同步省略*。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

    线程同步的代价是相当高的，同步的后果是降低并发性和性能。在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫**锁消除**。

3. *分离对象或标量替换*。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分(或全部)可以不存储在内存，而是存储在CPU寄存器中。

    - 标量(Scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。
    - 相对的，那些还可以分解的数据叫做聚合量(Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。
    - 在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。



### 方法区
方法区（Method Area）用于存储对象类型，线程共享。

方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。



**概述**

方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于*存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据*。《Java虚拟机规范》中明确说明:“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpotJVM而言，方法区还有一个别名叫做Non-Heap (非堆)，目的就是要和堆分开。所以，*方法区看作是一块独立于Java堆的内存空间*。

- 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。
- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误: `java.lang.OutOfMemoryError: PermGen space`或者`java.lang.OutOfMemoryError: Metaspace`
- 关闭JVM就会释放这个区域的内存。





方法区（Method Area）（线程共享区）位于堆中，当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息（包括类信息、常量、静态变量等）放到方法区中。

方法区虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态变量，即时编译器编译后的代码等数据
方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。

HotSpot虚拟机使用永久代来实现方法区，使得HotSpot虚拟机的垃圾收集器可以像管理堆内存一样来管理这部分内存，能省去专门为方法区编写内存管理代码工作。所以开发者喜欢将方法区称为永久代，本质上两者并不等价，对于其他虚拟机来说不存在永久代的概念。这样也会更容易造成内存溢出的问题（永久代可以用-XX:MaxPermSize设置上限），所以在JDK1.7的HotSpot已经把永久代的字符串常量池移出，移到了Java Heap区。

方法区同样存在垃圾收集，因为用户通过自定义加载器加载的一些类同样会成为垃圾， JVM会回收一个未被引用类所占的空间，以使方法区的空间达到最小。方法区可选择不实现垃圾收集，一般来说，这个区域对内存回收的条件较为苛刻，但是这部分区域的回收确实是必要的。

当方法区无法满足内存分配需求时，将会抛OutOfMemoryError异常。

《深入理解Java虚拟机》书中对方法区(Method Area)存储内容描述如下: 它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。

1. 类型信息

    对每个加载的类型(类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息:
    ①这个类型的完整有效名称(全名=包名.类名)
    ②这个类型直接父类的完整有效名(对于interface或是java. lang .0bject，都没有父类)
    ③这个类型的修饰符(public, abstract, final的某个子集)
    ④这个类型直接接口的一个有序列表

2. 域（Filed）信息

    JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。

    域的相关信息包括:

    - 域名称、域类型、域修饰符(public, private, protected, static, final, volatile, transient的某个子集)

3. 方法信息

    JVM必须保存所有方法的以下信息，同域信息一样包括声明顺序:

    - 方法名称

    - 方法的返回类型(或volid)

    - 方法参数的数量和类型(按顺序)

    - 方法的修饰符(public, private, protected, static, final,synchronized, native, abstract的一个子集)

    - 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)

    - 异常表( abstract和native方法除外)

        每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引



#### 常量池

常量池（方法区的一部分）包含着一些常量和符号引用（加载类的连接阶段中的解析过程会将符号引用转换为直接引用）。

常量池(constant pool)指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。它包括了关于类、方法、接口等中的基本类型常量和字符串常量，Java会确保一个字符串常量只有一个拷贝。

Java虚拟机对Class文件每一部分的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，然而对于运行时常量池却没做任何要求

运行时常量池相于class文件中的常量池，所不同的是其具备了动态性。class文件中常量池中的常量在编译期间就已经定义好了，而运行时常量池在程序运行期间也可以将常量放入该常量池中，最常见的做法就是调用String类的intern()方法。

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

一个java源文件中的类、接口，编译后产生一个字节码文件。而Java中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。

```java
public class SimpleClass {
	public void sayHello() {
		System.out.println("hello");
	}
}
```



虽然只有194字节，但是里面却使用了string、System、 PrintStream及Object等结构。这里代码量其实已经很小了。如果代码多，引用到的结构会更多! 这里就需要常量池了!

几种在常量池内存储的数据类型包括:

- 数量值
- 字符串值
- 类引用
- 字段引用
- 方法引用

例如下面这段代码:

```java
public class MethodAreaTest2 {
	public static void main(String[] args) {
		object obj = new object();
}
```

object foo = new object () ;

将会被编译成如下字节码:

```ruby
0:new #2           // Class java/ lang/ object
1:dup
2:invokespecial #3 // Method java/ lang/object "<init>"( ) v
```



**概述**

- 运行时常量池( Runtime Constant Pool) 是方法区的一部分。
- 常量池表(Constant Pool Table)是Class文件的一 部分，**用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中**。
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
- JVM为每个已加载的类型(类或接口)都维护一个常量池。池中的数据项像数组项一样，是通过***索引访问***的。
- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。
    - 运行时常量池，相对于Class文件常量池的另一重要特征是: ***具备动态性***
- 运行时常量池类似于传统编程语言中的符号表(symbol table) ，但是它所包含的数据却比符号表要更加丰富一些。
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛OutOfMemoryError异常。



#### 扩展

**StringTable为什么要调整？**

jdk7中将stringTable放到了堆空间中。因为永久代的回收效率很低，在full gc的时候才会触发。而full gc是老年代的空间不足、永久代不足时才会触发。这就导致StringTable回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。

### 永久代
> Java8之前


### 元空间
> Java8之后，永久代中的数据迁移到了与堆不相连的本地内存区域，即元空间。

元空间（Metaspace）线程共享，会抛出 OutOfMemoryError: Metaspace


======
由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。这项改动是很有必要的，原因有:

1. 为永久代设置空间大小是很难确定的

    在某些场景下，如果动态加载类过多，容易产生Perm区的OOM。比如某个实际Web工程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。

    Exception in thread dubbo client x.x connector' java.lang.OutOfMemoryError: PermGenspace

    而元空间和永久代之间最大的区别在于:元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。

2. 对永久代进行调优是很困难的。





### 虚拟机栈
JVM中栈（Stack）用于存储引用，内存较小，非线程共享，会抛出 StackOverflowError。

每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。



> 栈是运行时的单位，而堆是存储的单位



**定义**

- 每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应一次次的Java方法调用
- 是线程私有的，生命周期与线程一致
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法（栈的顶部）
- 主管Java程序的运行，保存方法的局部变量（基本数据类型，引用类型的地址）、部分结果，并参与方法的调用和返回
- 注意
    - 栈溢出（StackOverflowError, OutOfMemoryError）
    - 垃圾回收不涉及栈
    - 栈内存分配不是越大越好
    - 方法内的局部变量是否线程安全？
        - 如果只有一个线程才可以操作此数据，则是线程安全的
        - 如果多个线程操作此数据，则此数据是共享数据，如果不考虑同步机制，会存在线程安全问题
        - 如果方法内局部变量没有逃离方法的作用访问，则安全
        - 外部传入或者返回到外部，则不安全

**特点**

- 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器
- 只存在两种操作：入栈和出栈
- 不存在垃圾回收问题



Java虚拟机规范允许Java栈的大小是动态的或者固定不变的

- 如果采用固定大小的栈，可能会出现StackOverflowError异常，栈帧过多导致栈内存溢出、栈帧过大。如递归循环调用；

- 如果采用动态扩展的栈，可能会出现OutOfMemoryError异常。



**栈的存储单位**

- 栈中的数据以栈帧的格式存在，每个方法对应一个栈帧
- 栈帧是一个内存区块，是一个数据集
- 内部结构
    - 局部变量表（Local Variables）
    - 操作数栈（Operand Stack）
    - 动态链接（Dynamic Linking）（指向运行时常量池的方法引用）
    - 方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）
    - 一些附件信息



#### 内部结构

##### 局部变量表

- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用，以及returnAddress类型
- 局部变量所需的容量大小是在编译期间确定下来的
- 最基本的存储单元是Slot（变量槽）32位的类型占一个slot，64位的类型占用两个slot
- 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。
- 栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

##### 操作数栈

- 在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈、出栈
- 主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间
- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈，并更新PC寄存器中下一条需要执行的字节码指令
- Java虚拟机的解释引擎是基于栈的执行引擎，栈就是操作数栈
- 由于操作数是存储在内存中，因此频繁地执行内存读写会影响执行速度。为了解决这个问题，HotSpot JVM的设计者提出了栈顶缓存（ToS，Top-of-stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读写次数，提升执行引擎的执行效率。



##### 动态链接

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking) 。比如: invokedynamic指令
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。比如:描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。**



##### 方法的调用

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

- 静态链接: 当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知,且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
- 动态链接: 如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。

虚拟机中提供了以下几条方法调用指令:

- 普通调用指令:
    1. invokestatic: 调用静态方法，解析阶段确定唯一方法版本
    2. invokespecial: 调用`<init>`方法、私有及父类方法，解析阶段确定唯一方法版本
    3. invokevirtual: 调用所有虚方法
    4. invokeinterface: 调用接口方法
- 动态调用指令:
    1. invokedynamic: 动态解析出需要调用的方法，然后执行

> 前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而invokedynamic指令则支持由用户确定方法版本。其中invokestatic指令和invokespecial指令调用的方法称为非虚方法，其余的(final修饰的除外)称为虚方法。

**动态类型语言**和**静态类型语言**两者的区别：

就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。说的再直白一点就是，静态类型语言是判断变量自身的类型信息;动态类型语言是判断变量值的类型信息，变量没有类型信息，变量值才有类型信息，这是动态语言的一个重要特征。

Lambda的引入使得Java具备了动态类型语言的特性。总体来说还是静态。



##### 方法返回地址

- 存放调用该方法的pc寄存器的值
- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。



#### 线程运行诊断

1. CPU占用过高

    - 用top定位哪个进程对cpu的占用过高
    - ps H -eo pid,tid,%CPU | grep pid
    - jstack pid
        - 可以根据线程id找到有问题的线程，进一步定位到问题代码的源码行号

2. 程序运行很长时间没有结果

    使用jstack pid查看进程的运行情况，可发现死锁

    程序发生了死锁





虚拟机栈Stack又称Java栈，是一个后入先出的栈，其中保存的元素是栈帧 。

程序运行时，每调用一个方法就会生成一个栈帧，同时将当前正在执行方法的栈帧压入虚拟机栈。虚拟机栈顶的栈帧为“当前活跃栈帧”。栈帧包含局部变量表、操作数栈、动态链接、返回地址和其他信息。

局部变量表：一组局部变量值存储空间，用于存放方法参数和方法内部定义的局部变量，存放了编译期可知的各种基本数据类型和对象引用类型，通常我们所说的“栈内存”指的就是局部变量表这一部分。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，运行期间不会改变局部变量表的大小。64位的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。

操作数栈：一个以字长为单位的数组。但它不是通过索引来访问，而是通过标准的栈操作—压栈和出栈—来访问的。比如，如果某个指令A把一个值1压入到操作数栈中，指令B将值2压入栈中，稍后指令C就可以弹出这两个个值来进行相加计算，并将结果3压入栈中。通过操作数栈可以完成方法中的一些运算。

动态链接：每个栈帧内部都包含一个指向当前方法所在类型的运行时常量池的引用，以便对当前方法的代码实现动态链接。在class文件里面，一个方法如果要调用另外一个方法，或者访问其成员变量，则需要通过符号引用来表示，那么动态链接的作用就是在恰当的时候将这些以符号引用所表示的方法或是变量解析成直接引用。

返回地址：当一个方法被执行后，有两种退出方式：

1）当执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法方式称为正常完成出口 (Normal Method Invocation Completion)。

2）方法在执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方式称为异常完成出口 (Abrupt Method Invocation Completion)。一个方法使用异常完成出口的方式退出，是不会给它的调用都产生任何返回值的。

无论哪种方式退出，方法退出之前，都需要返回到方法被调用的位置，程序才能继续执行。方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。方法正常退出时，调用者PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器来确定的，栈帧中一般不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值(如果有的话)压入调用都栈帧的操作数栈中，调用PC计数器的值以指向方法调用指令后面的一条指令等。



虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与高度相关的信息，这部分信息完全取决于具体的虚拟机实现。

基础类型的变量和常量，变量和引用存储在栈中，常量存储在常量池中。另外，局部变量（形式参数）的数据存储在栈中，并且它随方法的消失而消失。

在内存固定大小的情况下，如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常；多数虚拟机栈可以动态扩展，扩展时无法申请到足够多的内存，就会抛出OutOfMemoryError异常。

虚拟机栈和线程是紧密联系的，每创建一个线程时就会对应创建一个Java栈，所以Java栈也是”线程私有”的内存区域，而且生命周期和线程相同。这个栈中又会对应包含多个栈帧，每调用一个方法时就会往栈中创建并压入一个栈帧，栈帧是用来存储方法数据和部分过程结果的数据结构，方法从调用到最终返回结果的过程，就对应一个栈帧从入栈到出栈的过程。

虚拟机栈是一个后入先出的数据结构，线程运行过程中，只有一个栈帧是处于活跃状态的，被称为”当前活动帧栈”，当前活动帧栈始终是虚拟机栈的栈顶元素。

也就是说,对于一个Java程序来说，它的运行就是通过对栈的操作来完成的。栈以帧为单位保存线程的状态。JVM对栈只进行两种操作：以帧为单位的压栈和出栈操作。我们知道,某个线程正在执行的方法称为此线程的当前方法。我们可能不知道，当前方法使用的帧称为当前帧。当线程激活一个Java方法，JVM就会在线程的 Java堆栈里新压入一个帧，这个帧自然成为了当前帧。在此方法执行期间，这个帧将用来保存参数、局部变量、中间计算过程和其他数据。从Java的这种分配机制来看,堆栈又可以这样理解：栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。

存放于栈中的东西如下：

每个线程包含一个栈区,栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)。对象都存放在堆区中。
每个栈中的数据(基础数据类型和对象引用)都是私有的，其他栈不能访问。

- 方法的形式参数，方法调用完后从栈空间回收
- 引用对象的地址，引用完后，栈空间地址立即被回收，堆空间等待GC



存放于堆中的东西如下：

- 存储的全部是对象，每个对象包含一个与之对应的class信息
- Jvm只有一个堆区被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身



存放于方法区中的东西如下：

- 存放线程所执行的字节码指令，跟堆一样.被所有线程共享.方法区包含：所有的class、字符串常量和static变量



一：在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因。在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。

1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中

2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。

二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量。

1）当声明的是基本类型的变量其变量名及其值放在堆内存中的

2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中



```java
public class Example {
	public static void main(String[] args) {
		new Test().testString("hoo");
		new Test().testInt();
	}
}
class Test{		
	String str = "hoo";
	int i = 10;
	void testString(String strm) {
		/*
		 * 此时的strm、str0、str1虽然都是局部变量，但是其指向的对象都是指向常量池中的"hoo"；因此他们都是相同的
		 */
		String str0 = strm;
		String str1 = str;
		System.out.print((str == str0)+"\t");
		System.out.print((str == str1)+"\t");
		System.out.println(str0 == str1);

	}
	void testInt() {
		//基本数据类型赋值直接赋的是值，而引用数据类型赋值传递的是对象的引用
		int j = i;
		j += 1;
		i += 2;
		System.out.println(i+""+j);
	}
}
```



### 本地方法栈　

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。

Java虚拟机栈用于管理Java方法的调用，而本地方法栈（Native Method Stacks）用于管理本地方法的调用。也是线程私有的。（线程独占区）　

本地方法栈Native Stack为线程私有，和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法，本地方法栈为虚拟机执行native方法。

线程在调用本地方法时，存储本地方法的调用状态，存储本地方法的局部变量表，本地方法的操作数栈等等信息。
HotSpot虚拟机不区分虚拟机栈和本地方法栈，两者是一块的。

与虚拟机栈一样，本地方法栈也会抛StackOverflowError和OutOfMemoryError异常。

为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。



#### Native Method

简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法: 该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern "C"告 知C+ +编译器去调用一个C的函数。

"A native method is a Java method whose implementation is provided by non-java code."

在定义一个native method时，并不提供实现体(有些像定义一个Java interface，因为其实现体是由非java语言在外面实现的。本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序 。

**为什么要使用Native Method？**

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

1. 与Java环境外交互
    *有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。*你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

2. 与操作系统交互
    JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器(解释字节码)和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。*通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM**的一些部分就是用c写的。*还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

3. Sun's Java
    *Sun的解释器是用c实现的，这使得它能像一些普通的C一样与外部交互*。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如:类java. lang.Thread的setPriority() 方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用win32 SetPriority() API. 这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library) 提供，然后被JVM调用。

4. 现状

    目前该方法使用的越来越少了，除非是与硬件有关的应用，比如通过Java程序驱动打印机或者Java系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用Socket通信，也可以使用web Service等等，不多做介绍。

**概述**

- *当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虛拟机拥有同样的权限。*

    - 本地方法可以通过本地方法接口来访问**虚拟机内部的运行时数据区**。
    - 它甚至可以直接使用本地处理器中的寄存器
    - 直接从本地内存的堆中分配任意数量的内存。

- *并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。*如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。

    - 在Hotspot JVM中， 直接将本地方法栈和虚拟机栈合二为一 。

    

### 程序计数器

> Program Counter Register（PC寄存器）（线程独占区），JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟
>



- 一块很小的内存空间，几乎可以忽略不记，运行速度最快的存储区域
- 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
- 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
- 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。
- 此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。
- 线程私有，与线程生命周期一致



#### 作用

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。



#### 记录内容

例如如下代码文件Hello.java

```java
public class Hello 
{
	public static void main(String[] args) 
	{
		System.out.println("hello");
	}
}
```



经过编译之后生成Hello.class字节码文件，使用javap反汇编命令查看class文件数据格式，得到如下代码：

```java
public class Hello {
  public Hello();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
       3: ldc           #3                  // String hello
       5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
       8: return
}
```



每一行开头的数字部分就是字节码指令的偏移地址也就是字节码的行号，程序计数器中存储就是这些行号数字。



#### 扩展

##### **为什么设定为线程私有**

为了保证线程中断或恢复时，能保证正确执行指令，因此程序计数器是私有的，和其它线程互不干扰。



### 总结

| 数据区域   | 线程私有 | 数据内容 | 生命周期   | 垃圾回收 | 版本          |
| ---------- | -------- | -------- | ---------- | -------- | ------------- |
| 堆         | 非私有   |          |            |          |               |
| 方法区     | 非私有   |          |            |          | JDK 1.8之前   |
| 元空间     | 非私有   |          |            |          | JDK 1.8及之后 |
| 虚拟机栈   | 私有     |          | 和线程一致 | 无       |               |
| 本地方法栈 | 私有     |          |            | 无       |               |
| 程序计数器 | 私有     | 指令地址 | 和线程一致 | 无       |               |



## 执行过程

JVM的多线程是通过线程轮流切换并分配CPU执行时间片的方式来实现的，任何一个时刻，一个CPU都只会执行一条线程中的指令。为了保证线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程间的程序计数器独立存储，互不影响，因此程序计数器为线程私有的。

线程内

当线程获得时间片处于执行过程时，CPU会按照程序计数器中存储的内容依次的取出指令执行，当CPU取出当前指令时，CPU自动修改程序计数器内容，使其指向下一条指令字节码行号。由于程序计数器中存储的是数字值，因此不会随着程序运行而扩大需求空间，JVM的程序计数器寄存器的宽度足够保证可以持有一个返回地址或者native的指针。故不会发生溢出。

线程间切换

假设线程A正在执行，当执行到某个阶段，优先级更高线程B执行。此时，线程A挂起，线程B执行。当线程B执行完毕后，需要唤醒线程A继续执行，那么如何从线程A的中断位置继续执行呢，那就需要CPU访问线程A的程序计数器，从中获取下一条执行指令，保证程序继续执行。由于每个线程需要保存自身的执行位置，也就使得程序计数器为线程私有。

native方法

native本地方法大多是通过C实现并未编译成需要执行的字节码指令，所以在计数器中是undefined。

程序计数器特性

1） 因为处理器在一个确定是时刻只会执行一个线程中的指令，线程切换后，是通过计数器来记录执行痕迹的，因而可以看出，程序计数器是每个线程私有的。

2） 如果执行的是java方法，那么记录的是正在执行的虚拟机字节码指令的内存地址（可以理解为上图所示的行号），如果是native方法，计数器的值为空（undefined）。

3 ）这个内存区域是唯一一个在java虚拟界规范中没有规定任何OutOfMemoryError的情况的区域，因为程序计数器是由虚拟机内部维护的，不需要开发者进行操作。

直接内存

直接内存，就是JVM以外的机器内存。JDK中有一种基于通道（channel)和缓冲区（buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在jvm堆中的DirctByteBuffer来引用。
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域，是使用本机的内存，又名堆外内存。

虽然堆外内存不受Java堆大小的管理，但是受本机总内存以及处理器寻址空间的限制。在服务器管理员配置虚拟机参数的时候，可以通过-Xmx等来配置Java虚拟机最大内存，但经常忽略直接内存，导致各个内存区域总和大于物理内存限制，导致OutOfMemoryError异常。

## 内存实例

实例1

```java
/**
（1）用户创建了一个Student对象，运行时JVM首先会去方法区寻找该对象的类型信息，没有则使用类加载器classloader将Student.class字节码文件加载至内存中的方法区，并将Student类的类型信息存放至方法区。
（2）接着JVM在堆中为新的Student实例分配内存空间，这个实例持有着指向方法区的Student类型信息的引用，引用指的是类型信息在方法区中的内存地址。
（3）在此运行的JVM进程中，会首先起一个线程跑该用户程序，而创建线程的同时也创建了一个虚拟机栈，虚拟机栈用来跟踪线程运行中的一系列方法调用的过程，每调用一个方法就会创建并往栈中压入一个栈帧，栈帧用来存储方法的参数，局部变量和运算过程的临时数据。上面程序中的stu是对Student的引用，就存放于栈中，并持有指向堆中Student实例的内存地址。
（4）JVM根据stu引用持有的堆中对象的内存地址，定位到堆中的Student实例，由于堆中实例持有指向方法区的Student类型信息的引用，从而获得add()方法的字节码信息，接着执行add()方法包含的指令。 
 */
public class Example {
	//类加载时将类信息放在方法区内，堆内生成java.lang.class对象，持有指向方法区该类的引用

    /*
     * i1,i2都为Integer对象的引用，线程运行时放在java栈中新建的帧栈中
     *  该两个引用执行堆中的Integer实例的引用，而两实例在堆中的地址是不同的，所以，i1==i2返回false
     */
    static Integer i1=new Integer(1);
    static Integer i2=new Integer(1);

    /*
     * a,b引用同样放在java栈中帧栈中，指向常量池中的同一内存空间，所以，a==b返回true
     */
    static Integer a=1;
    static Integer b=1;

    public static void main(String[] args){//main方法放入方法区
	/*
	stu是对student对象的引用，放入栈中，指向堆中对象的内存地址。
	new出来的student对象放在堆中，并持有方法区中student类型信息的引用
	*/
	Student stu=new Student("jialimin");      
	/*
	执行add方法时，根据java栈中stu定位到堆中的对象实例，再根据堆中持有的位于方法区的student类型信息，获得add()
	字节码，执行此方法执行，打印出结果
	*/
        stu.add();
    }
}

class Student{
    public String name;
    public Student(String name){
        this.name=name;
    }
    public void add(){
        System.out.println(name);
    }
}
```



## 相关命令

### 堆

- -XX:+PrintFlagsInitial :查看所有的参数的默认初始值

- -XX: +PrintFlagsFinal :查看所有的参数的最终值(可能会存在修改，不再是初始值)

    - 具体查看某个参数的指令：
        - jps 查看运行进程
        - jinfo -flag SurvivorRatio 进程id

- -Xms: 初始堆空间内存 (默认为物理内存的1/64)

- -Xmx: 最大堆空间内存(默认为物理内存的1/4)

- -Xmn: 设置新生代的大小。(初始值及最大值)

- -xx:NewRatio: 配置新生代与老年代在堆结构的占比

- -XX:SurvivorRatio: 设置新生代中Eden和S0/S1空间的比例

- -XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄

- -Xx:+PrintGCDetails: 输出详细的GC处理日志

    打印gc简要信息:`-XX:+PrintGC` 或者 `-verbose:gc`

- -XX:HandlePromotionFailure: 是否设置空间分配担保



### 设置方法区大小与OOM

jdk8及以后:

- 元数据区大小可以使用参数`-XX : MetaspaceSize`和`-XX :MaxMetaspaceSize`指定,替代上述原有的两个参数。
- 默认值依赖于平台。windows下，`-XX :MetaspaceSize`是21M， `-XX:MaxMetaspaceSize`的值是-1，即没有限制。
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。
    如果元数据区发生溢出，虚拟机一样会抛出异常`OutOfMemoryError: Metaspace`
- `-XX:MetaspaceSize`:设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的`-XX:MetaspaceSize`值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类(即这些类对应的类加载器不再存活) ,然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过`MaxMetaspaceSize`时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会 发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC，建议将`-XX :MetaspaceSize`设置为一个相对较高的值。



### 参考资料

- [[官网说明书](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)]



## 常见面试题

百度

- 三面:说一下JVM内存模型吧，有哪些区?分别干什么的?

蚂蚁金服

- Java8的内存分代改进
- JVM内存分哪几个区，每个区的作用是什么?
- 一面: JVM内存分布/内存结构?栈和堆的区别?堆的结构?为什么两个survivor区?
- 二面: Eden和Survior的比例分配

小米

- jvm内存分区，为什么要有新生代和老年代

字节跳动

- 二面: Java的内存分区
- 二面: 讲讲jvm运行时数据库区
- 什么时候对象会进入老年代?

京东

- JVM的内存结构，Eden 和Survivor比例。
- JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor.

天猫

- 一面: Jvm内存模型以及分区，需要详细到每个区放什么。
- 一面: JVM的内存模型，Java8做了什么修改

拼多多

- JVM内存分哪几个区，每个区的作用是什么?

美团

- java内存分配
- jvm的永久代中会发生垃圾回收吗?
- 一面: jvm内存分区，为什么要有新生代和老年代?