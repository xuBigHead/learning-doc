# 目录

[TOC]



# 生产应用

## 缓存失效场景

### 缓存穿透

#### 定义

缓存穿透是指查询一个一定不存在的数据，每次请求都要到数据库去查询，失去了缓存的意义。



#### 解决方案

##### 布隆过滤器

采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，不存在的数据会被bitmap拦截掉，从而避免了对底层存储系统的查询压力。



**缺陷**

该方案要求技术难度，且可能会有一定的误差。



##### 缓存空结果

如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），仍然把这个空结果进行缓存，并设置一个较短的过期时间。



**缺陷**

在过期时间内可能会查不到最新的数据，导致数据不一致。



### 缓存击穿

#### 定义

缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发请求过来，这些请求发现缓存过期一般都会从数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把数据库压垮。



#### 解决方案

##### 互斥锁

缓存失效时，不是立即请求数据库，而是先设置一个缓存互斥锁，如果设置成功，则去查询数据库；如果设置失败，则表示有其他请求正在查询数据库并更新缓存。此时只要重试从缓存中获取数据即可。



```java
public String get(key) {
    String value = redis.get(key);
    //代表缓存值过期 
    if (value == null) {
        //设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load 数据库  
        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {
            //代表设置成功
            value = 数据库.get(key);
            redis.set(key, value, expire_secs);
            redis.del(key_mutex);
        } else {
            //这个时候代表同时候的其他线程已经load 数据库并回设到缓存了，这时候重试获取缓存值即可 
            sleep(50);
            //重试  
            get(key);
        }
    } else {
        return value;
    }
}
```



**缺陷**

降低了系统的处理并发的能力，存在死锁的风险。



##### 提前互斥

在value内部设置1个超时值(timeout1)，timeout1比实际的超时值(timeout2)小。当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache，然后再从数据库加载数据并设置到cache中。



**缺陷**

降低了系统的处理并发的能力，存在死锁的风险。



##### 永远不过期

针对某些场景下的缓存数据，可以不设置过期时间，从而使缓存永远不过期。



**缺陷**

该方案缺乏通用性，只能针对某些缓存不会频繁变化的场景使用。



#### 缓存击穿与缓存穿透的区别

缓存击穿是指存在的数据设置的缓存过期那一段时间内有大量请求导致数据库压力过大；缓存穿透指不存在的数据，因为没有缓存而导致不停的请求数据库，导致数据库压力过大。



### 缓存雪崩

#### 定义

缓存雪崩是指设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到数据库，数据库瞬时压力过重雪崩。



#### 解决方案

##### 随机过期时间

在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，从而降低发生缓存雪崩的概率。



**缺陷**

不适用与强制指定规定时长的过期时间的场景。



##### 限流

限制每秒请求数次，剩余的请求走降级处理，返回一些默认的值或友情提示等默认操作。



**缺陷**

用户不友好，部分用户无法使用。



## 数据一致性

在分布式环境下，缓存和数据库很容易出现数据一致性问题，如果项目对缓存的要求是强一致性，那就不要使用缓存。

只能在项目中使用策略降低缓存与数据库一致性的概率，是无法保障两者的强一致性，一般策略包括缓存更新机制，更新数据库后及时更新缓存、缓存失败时增加重试机制。

